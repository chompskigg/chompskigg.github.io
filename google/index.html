<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Spencer Luke | Google</title>
   <script src="https://cdn.tailwindcss.com"></script>
   <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&display=swap">
   <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@400;700&family=Roboto:wght@400;500&display=swap" rel="stylesheet">
   <style>
       body {
           font-family: 'Inter', sans-serif;
           background-color: #131514c4;
           color: #ffffff;
           margin: 0;
           padding: 0;
           background: url('assets/images/background.jpg') no-repeat center center fixed;
           background-size: cover;
           display: flex;
           flex-direction: column;
           min-height: 100vh;
       }
      
       .container {
           max-width: 1000px;
           margin: 0 auto;
           padding: 2rem 1rem;
           flex-grow: 1;
       }


       .font-merriweather {
           font-family: 'Merriweather', serif;
           line-height: 1.25 !important;
       }


       .content-card {
           background-color: #131514c4;
           border-radius: 1rem;
           padding: 2rem;
           margin-bottom: 2rem;
           box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
       }


       .styled-list {
           list-style-type: disc;
           padding-left: 1.5rem;
       }
      
       .styled-list li, .styled-list p, .text-content p {
           font-size: 1.125rem;
           line-height: 1.75rem;
           color: #ffffff;
       }


       .styled-table th, .styled-table td {
           padding: 0.5rem;
           text-align: left;
           vertical-align: top;
       }


       .styled-table th {
           font-weight: bold;
           color: #ffffff;
       }


       .styled-table thead th {
           border-bottom: 2px solid rgba(255, 255, 255, 0.2);
       }


       .button {
           display: inline-flex;
           align-items: center;
           background-color: #2d2d2d;
           color: white;
           font-family: 'Inter', sans-serif;
           letter-spacing: 0.05em;
           text-align: center;
           padding: 0.75rem 1.25rem;
           text-decoration: none;
           font-size: 1rem;
           border-radius: 0.5rem;
           transition: background-color 0.3s;
           margin-bottom: 1rem;
       }


       .button:hover {
           background-color: #4a4a4a;
       }


       .button svg {
           margin-right: 0.5rem;
       }

       .big-inter-text {
            font-family: 'Inter', sans-serif !important;
            font-size: 18px !important;
            line-height: 1.5 !important;
        }
        .small-inter-text {
            font-family: 'Inter', sans-serif !important;
            font-size: 14px !important;
            line-height: 1.5 !important;
        }

        .carousel-container {
            -ms-overflow-style: none; 
            scrollbar-width: none;
        }
        .carousel-container::-webkit-scrollbar {
            display: none;
        }
        .scroll-item {
            flex-shrink: 0;
            width: 100%;
        }
        .nav-arrow {
            transition: all 0.2s;
        }
        .nav-arrow:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .nav-arrow:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        #protected-content {
            display: none;
        }

        /* StatiCrypt CSS*/
        .staticrypt-password-container {
           position: relative;
           outline: 0;
           width: 100%;
           border: 0;
           margin: 0 0 15px;
       }
       .staticrypt-password-container input {
           color: #000000; /* Make text visible against light background */
       }
       .staticrypt-form input[type="password"] {
           background: inherit;
           border: 0;
           font-size: 14px;
           outline: 0;
           padding: 15px 15px 15px 15px;
           width: 100%;
       }

   </style>
</head>

<body class="flex flex-col min-h-screen">


   <!-- Navigation bar -->
   <nav class="bg-[#131514c4] p-4 flex justify-between items-center shadow-lg">
       <div class="container flex justify-end sm:justify-between items-center px-4">
           <span class="hidden sm:block text-white text-2xl font-semibold"><a href="/" class="hover:text-gray-400">spencer luke</a></span>
           <ul class="flex space-x-6">
               <li><a href="/" class="text-white hover:text-gray-400 text-xl font-semibold">work</a></li>
               <li><a href="about/" class="text-white hover:text-gray-400 text-xl font-semibold">about</a></li>
               <li><a href="https://drive.google.com/file/d/1QOIxv4yUMhOUyKNPmPDkbpIku_KGq-np/view?usp=sharing" class="text-white hover:text-gray-400 text-xl font-semibold">resume</a></li>
           </ul>
       </div>
   </nav>


   <!-- Main content container -->
   <div class="container mt-16 flex-grow">
        <div class="flex flex-col md:flex-row justify-between items-center p-4 gap-8">
            <h1 class="text-3xl md:text-[48px] font-bold font-serif">
                <span class="font-merriweather">Gemini and Agentic Tools <span class="text-gray-400">for Google</span></span>
            </h1>
        </div>
      
       <!-- Redesigned Overview Section -->
       <section class="content-card">
           <div class="flex flex-col md:flex-row gap-8 text-content">
               <!-- Left column for Summary -->
               <div class="flex-1">
                   <h3 class="text-xl font-semibold text-gray-400 tracking-widest mb-2 small-inter-text">Summary</h3>
                   <p class="big-inter-text">During my 3-month UXR internship at Google, I worked on several AI projects, including a Gemini 2.5 flash Q&A tool with LLM summarization and question clustering, an AI sentiment analyzer, and an agentic 'chief of staff' for enterprise use cases. Each project required a unique research approach. I leveraged methodologies like semi-structured interviews, concept tests, discussion guide and focus group design, and created novel validation testing techniques including an interactive vibe coded UI to simulate an intended user experience. My work had a direct impact on shipping product teams and future vision states for AI products within Google. Throughout my internship, I worked closely with another UXD intern, my staff-level UXR and UXD hosts, and two senior Product Managers.</p>
               </div>
               <!-- Right column for Details Grid -->
               <div class="flex-1 grid grid-cols-1 sm:grid-cols-2 gap-8 text-sm ">
                   <div>
                       <h4 class="font-semibold text-gray-400 tracking-widest mb-1 small-inter-text">Role</h4>
                       <p>UX Researcher</p>
                   </div>
                   <div>
                       <h4 class="font-semibold text-gray-400 tracking-widest mb-1 small-inter-text">Team</h4>
                       <p>1 Researcher, 1 Designer</p>
                   </div>
                   <div>
                       <h4 class="font-semibold text-gray-400 tracking-widest mb-1 small-inter-text">Timeline</h4>
                       <p>May 2025 - August 2025</p>
                   </div>
                   <div>
                       <h4 class="font-semibold text-gray-400 tracking-widest mb-1 small-inter-text">Tools</h4>
                       <p>Figma, GVC, Slides, Docs</p>
                   </div>
                   <div>
                       <h4 class="font-semibold text-gray-400 tracking-widest mb-1 small-inter-text">Methods</h4>
                       <p>Interview, Focus Group, Survey</p>
                   </div>
                   <div>
                       <h4 class="font-semibold text-gray-400 tracking-widest mb-1 small-inter-text">Design</h4>
                       <p>Prototyping, Design Recommendations</p>
                   </div>
               </div>
           </div>
       </section>

       <section id="password-section-container" class="w-full content-card flex flex-col md:flex-row items-start gap-8 p-6 rounded-lg shadow-md justify-center">
            <div class="w-full max-w-2xl p-8 rounded-xl shadow-2xl transition-all duration-300">
                <h1 class="text-4xl font-bold mb-4 text-center">Password Protected</h1>
                <p class="mb-6 text-center big-inter-text">Enter password to view case study</p>

                <form id="staticrypt-form" action="#" method="post">
                    <div class="staticrypt-password-container relative">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Enter password..."
                            autofocus
                            class="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-white focus:ring-sky-500 focus:border-sky-500 transition duration-150 pr-10"
                        />
                        <button
                            type="button"
                            id="toggle-password-visibility"
                            class="absolute right-3 top-1/2 -translate-y-1/2 text-gray-400 hover:text-gray-200 focus:outline-none"
                        >
                            <!-- Eye closed icon (default) -->
                            <svg id="eye-closed" xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" class="h-5 w-5">
                            <path d="M12 4.5c-7 0-10.8 7.2-10.9 7.4a1 1 0 0 0 0 .9c.1.2 3.9 7.4 10.9 7.4s10.8-7.2 10.9-7.4a1 1 0 0 0 0-.9C22.8 11.7 19 4.5 12 4.5zM12 18c-5.3 0-8.4-4.4-9.5-6 1.1-1.6 4.2-6 9.5-6 5.3 0 8.4 4.4 9.5 6-1.1 1.6-4.2 6-9.5 6zm0-10a4 4 0 1 0 0 8 4 4 0 0 0 0-8zm0 6a2 2 0 1 1 0-4 2 2 0 0 1 0 4z"/>
                            </svg>
                            <!-- Eye open icon (hidden by default) -->
                            <svg id="eye-open" xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" class="h-5 w-5 hidden">
                            <path d="M12 5c-7 0-11 7-11 7s4 7 11 7 11-7 11-7-4-7-11-7zm0 12c-2.8 0-5-2.2-5-5s2.2-5 5-5 5 2.2 5 5-2.2 5-5 5zm0-8a3 3 0 1 0 0 6 3 3 0 0 0 0-6z"/>
                            </svg>
                        </button>
                        </div>
                    <input type="submit" class="w-full text-center p-3 text-lg text-white bg-sky-600 rounded-lg hover:bg-sky-700 transition duration-150 block mt-4 staticrypt-decrypt-button" value="Unlock" />
                    <p id="decryption-error-message" class="text-red-500 mt-2 hidden big-inter-text">Incorrect Password. Please try again.</p>
                </form>
                </div>
       </section>

       <div id="protected-content" style="display:none;"></div>
       


    <!-- Footer at the bottom with social links -->
    <footer class="bg-[#131514c4] p-5 mt-auto shadow-inner text-center text-xl">
    <div class="flex justify-center space-x-6">
        <a href="https://www.linkedin.com/in/spencer-luke/" class="text-white hover:text-gray-400 flex items-center space-x-1.5">
            <!-- LinkedIn Icon -->
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" class="h-5 w-5">
                <path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"/>
            </svg>
            <span>LinkedIn</span>
        </a>
        <a href="https://github.com/chompskigg" class="text-white hover:text-gray-400 flex items-center space-x-1.5">
            <!-- GitHub Icon -->
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" class="h-5 w-5">
                <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.465-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.046.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.6.804.576 4.765-1.589 8.196-6.091 8.196-11.386 0-6.627-5.373-12-12-12z"/>
            </svg>
            <span>GitHub</span>
        </a>
        <a href="mailto:spencerluke011@gmail.com" class="text-white hover:text-gray-400 flex items-center space-x-1.5">
            <!-- Email Icon -->
            <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 16 16" class="h-5 w-5">
                <path d="M.05 3.555A2 2 0 0 1 2 2h12a2 2 0 0 1 1.95 1.555L8 8.414.05 3.555ZM0 4.697v7.104l5.803-3.558L0 4.697ZM6.761 8.83l-6.57 4.027A2 2 0 0 0 2 14h12a2 2 0 0 0 1.808-1.144l-6.57-4.027L8 9.585l-1.239-.755Z"/>
                <path d="M16 4.697v7.104l-5.803-3.558L16 4.697Z"/>
            </svg>
            <span>Email</span>
        </a>
    </div>
    </footer>
    <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f904ef33d2af1aca2ca3fa16a81213a48a86ad2515b708cf7587e8034954f9a3df8bf7d48012ed6cba64c004d3c9cdf997f8765f1077e3de8543b7090e27fbcda7294dc7d98f50eee4fb125d6e3351e2466dafe590a033d0b9d932cbd049b964264cbc23f26bbb7bad07c261878cf872a27aff2f05760e1d67e300287a98a31e5286f1b875aa43c71a9063ee2c13ae9ea4153b96efff836531f7ed3703cf29d1eb8c06b0b10d280973cf6f8f505c50a3735132f7721800b9a2b6d1b78b8b52dc3611d8f4f7b6032ccb20c490c2f6d750c46aff8d87a97b1ab02fc871f67dea5a476677751db136eacc7074b665ed3451829265dccd10801b9a621b0102c33d5337e04cc6f4bd3701953478229855e5ae73f4b05d1e64651cf16706dc45ab9683c40056bbfe71b51957a7b2206dccb0df0d574bff1d340a29cec18342b5a54b82fc380eab074409240d44144a4e0660c65d741d08efa17833ea4f0f275081f7d4dae93b95acd5305bba639cabd6ef546727883befd9a6cb7e7731a00070a7509e6133409cba24870cc027c982dda5bb567894798f48f837e1878d99d5503899eabb696da4e25ab6e6dad4074626b60bfe3ad32a16be899565035c51b12b4d1ec9f94419b5bc9849db7a153e5d6f22ea19deb8215d57ffbc7f3a1cbdf83b212620fdd8db2f173682232da651abd539f902f6ad8cd31c6412fc3a1bc55a88d889494602a6c1d0941c7d2c81b903a6820c91c56e13652acc2a9d9c8af29800bbe32da70590a06fa872c3a939e0f61f60d85be75ddb701c6a1a7b3db40702b2a99fe79287e84a4a69dd3ea0270faff909c2b664bedc5a5fc028499c072d917d96fbf88857041ea4006861dc7c74f21929103e0ba431e4884cb5b9fdde75b3667717cfa71a8ed7f8adf0931e3535b411769bf04981f17af3fc68b552bc9f9a3048739dce598a8b2dcc4a71bc69f2f659bd3c96b7f0d04b4a7027f4cbcbc5f08d46ad5b5c00b55a61394ed1d219c9caf9a9c063ea7a7e729dceba746cebe8f3445281d335ea96b1f171331a165325f705a1ba0ede0c09009d5c4d594d304b55d448f365bce65d83e658cbd96fb0dd84ae3aae2306c7ed4f9ffd950c813431937127ab685aa3fa02bb2051948464f007d9d36e743d3fb2c1c1c009dfe525a9df29f29e0c58f99530493346f3bc627e080b8a2587","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1b123612123ce52c0b378f92e6b5580f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",

                // ðŸ‘‡ Custom callback: inject decrypted HTML into #protected-content instead of replacing the page
                replaceHtmlCallback: function (plainHTML) {
                    const container = document.getElementById("protected-content");
                    const passwordSection = document.getElementById("password-section-container");

                    if (container) {
                        container.innerHTML = plainHTML;
                        container.style.display = "block";
                    }

                    if (passwordSection) {
                        passwordSection.style.display = "none";
                    }
                },

                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                try {
                    const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                    // If nothing decrypted, show your password UI and focus the input
                    if (!isSuccessful) {
                    // If the template left any loading element, hide it safely
                    const loading = document.getElementById("staticrypt_loading");
                    if (loading && loading.classList) loading.classList.add("hidden");

                    // Show the password section you created (password-section-container)
                    const mySection = document.getElementById("password-section-container");
                    if (mySection) mySection.style.display = ""; // un-hide if it was hidden

                    // Focus the password input if present
                    const pwd = document.getElementById("staticrypt-password");
                    if (pwd) pwd.focus();

                    // Reveal remember me if your template enabled it and the label exists
                    if (isRememberEnabled) {
                        const rememberLabel = document.getElementById("staticrypt-remember-label");
                        if (rememberLabel) rememberLabel.classList.remove("hidden");
                    }
                    }
                    // if it decrypted on load, the replaceHtmlCallback or document.write has already fired
                } catch (err) {
                    console.error("staticrypt onload error:", err);
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            if (toggleIcon) {
                const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
                const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";

                toggleIcon.addEventListener("click", function () {
                    const passwordInput = document.getElementById("staticrypt-password");
                    if (!passwordInput) return;
                    if (passwordInput.type === "password") {
                        passwordInput.type = "text";
                        toggleIcon.src = imgSrcEyeOpened;
                        toggleIcon.alt = templateToggleAltHide;
                        toggleIcon.title = templateToggleAltHide;
                    } else {
                        passwordInput.type = "password";
                        toggleIcon.src = imgSrcEyeClosed;
                        toggleIcon.alt = templateToggleAltShow;
                        toggleIcon.title = templateToggleAltShow;
                    }
                });
            }
           

            // === Password visibility toggle ===
            const toggleBtn = document.getElementById("toggle-password-visibility");
            const passwordInput = document.getElementById("staticrypt-password");
            const eyeOpen = document.getElementById("eye-open");
            const eyeClosed = document.getElementById("eye-closed");

            if (toggleBtn && passwordInput) {
            toggleBtn.addEventListener("click", () => {
                const isPassword = passwordInput.type === "password";
                passwordInput.type = isPassword ? "text" : "password";
                if (eyeOpen && eyeClosed) {
                eyeOpen.classList.toggle("hidden", !isPassword);
                eyeClosed.classList.toggle("hidden", isPassword);
                }
            });
            }

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const passwordInput = document.getElementById("staticrypt-password");
                const rememberInput = document.getElementById("staticrypt-remember");

                const password = passwordInput ? passwordInput.value : "";
                const isRememberChecked = rememberInput ? rememberInput.checked : false;
                    

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
                if (isSuccessful) {
                    document.getElementById("password-section-container").style.display = "none";
                    document.getElementById("protected-content").style.display = "block";
                } else {
                    document.getElementById("decryption-error-message").classList.remove("hidden");
                }
            });
        </script>
</body>
</html>



